/*
 * HiDialect, a tiny SQL dialect tool 
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
 * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
 */
package com.github.drinkjava2.hidialect;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;

/**
 * <pre>
 * This is a common dialects for all kind of Databases, most are extracted from Hibernate
 * 
 * Note: Do not modify this file manually, it's generated by source code generator
 * 
 * </pre>
 *
 * @author Yong Zhu
 * @version 1.0.0
 * @since 1.0.0
 */
public enum Dialect {
	SQLite, Cache71, CUBRID, DataDirectOracle9, DB2, DB2390, DB2400, Derby, DerbyTenFive, DerbyTenSeven, DerbyTenSix, Firebird, FrontBase, H2, HANAColumnStore, HANARowStore, HSQL, Informix, Informix10, Ingres, Ingres10, Ingres9, Interbase, JDataStore, MariaDB, MariaDB53, Mckoi, MimerSQL, MySQL, MySQL5, MySQL55, MySQL57, MySQL57InnoDB, MySQL5InnoDB, MySQLInnoDB, MySQLMyISAM, Oracle, Oracle10g, Oracle12c, Oracle8i, Oracle9, Oracle9i, Pointbase, PostgresPlus, PostgreSQL, PostgreSQL81, PostgreSQL82, PostgreSQL9, PostgreSQL91, PostgreSQL92, PostgreSQL93, PostgreSQL94, PostgreSQL95, Progress, RDMSOS2200, SAPDB, SQLServer, SQLServer2005, SQLServer2008, SQLServer2012, Sybase, Sybase11, SybaseAnywhere, SybaseASE15, SybaseASE157, Teradata, Teradata14, TimesTen;// NOSONAR

	public static final String NOT_SUPPORTED = "NOT SUPPORT";

	/**
	 * Return a Pagination Sql Template
	 * 
	 * @return
	 */
	public String getPaginSqlTemplate() {// NOSONAR
		switch (this) {// NOSONAR
		case H2:
		case HANAColumnStore:
		case HANARowStore:
		case PostgreSQL:
		case PostgreSQL81:
		case PostgreSQL82:
		case PostgreSQL9:
		case PostgreSQL91:
		case PostgreSQL92:
		case PostgreSQL93:
		case PostgreSQL94:
		case PostgreSQL95:
		case PostgresPlus:
		case SQLite:
			return "$SQL limit $MAX offset $OFFSET";
		case CUBRID:
		case MariaDB:
		case MariaDB53:
		case MySQL:
		case MySQL5:
		case MySQL55:
		case MySQL57:
		case MySQL57InnoDB:
		case MySQL5InnoDB:
		case MySQLInnoDB:
		case MySQLMyISAM:
			return "$SQL limit $OFFSET, $MAX";
		case Ingres10:
		case Ingres9:
			return "$SQL offset $OFFSET fetch first $MAX rows only";
		case Derby:
		case DerbyTenFive:
		case DerbyTenSeven:
		case DerbyTenSix:
		case Oracle12c:
		case SQLServer2012:
			return "$SQL offset $OFFSET rows fetch next $MAX rows only";
		case Interbase:
			return "$SQL rows $OFFSET to $END";
		case Cache71:
		case DB2390:
		case FrontBase:
		case Informix:
		case Ingres:
		case JDataStore:
		case Mckoi:
		case MimerSQL:
		case Pointbase:
		case Progress:
		case RDMSOS2200:
		case SAPDB:
		case SQLServer:
		case Sybase:
		case Sybase11:
		case SybaseASE15:
		case SybaseASE157:
		case SybaseAnywhere:
		case Teradata:
		case Teradata14:
		case TimesTen:
			return "NOT SUPPORT";
		case SQLServer2005:
		case SQLServer2008:
			return "WITH query AS (SELECT inner_query.*, ROW_NUMBER() OVER (ORDER BY CURRENT_TIMESTAMP) as _rownum_ FROM ( select TOP($MAX) $BODY ) inner_query ) SELECT $MSSQL_ORDERBY FROM query WHERE _rownum_ >= $OFFSET AND _rownum_ < $END";
		case DB2:
		case DB2400:
			return "select * from ( select inner2_.*, rownumber() over(order by order of inner2_) as rownumber_ from ( $SQL fetch first $END rows only ) as inner2_ ) as inner1_ where rownumber_ > $OFFSET order by rownumber_";
		case Oracle:
		case Oracle8i:
			return "select * from ( select row_.*, rownum rownum_ from ( $SQL ) row_ ) where rownum_ <= $END and rownum_ > $OFFSET";
		case DataDirectOracle9:
		case Oracle10g:
		case Oracle9:
		case Oracle9i:
			return "select * from ( select row_.*, rownum rownum_ from ( $SQL ) row_ where rownum <= $END) where rownum_ > $OFFSET";
		case Informix10:
			return "select SKIP $OFFSET FIRST $MAX $BODY";
		case Firebird:
			return "select first $OFFSET skip $MAX $BODY";
		case HSQL:
			return "select limit $OFFSET $MAX $BODY";
		default:
			return "";
		}
	}

	/**
	 * Create a pagination SQL by given pageNumber, pageSize and SQL
	 * 
	 * @param pageNumber
	 *            pageNumber started from 0
	 * @param pageSize
	 *            page size
	 * @param sql
	 *            the original sql
	 * @return the pagination SQL String
	 */
	public String pagin(int pageNumber, int pageSize, String sql) {
		if (!StringUtils.startsWithIgnoreCase(sql, "select "))
			return (String) DialectException.throwEX("SQL should be started with \"select \".");
		String body = sql.substring(7);
		String pagintemplate = this.getPaginSqlTemplate();
		if (Dialect.NOT_SUPPORTED.equals(pagintemplate))
			return (String) DialectException
					.throwEX("This dialect \"" + this + "\" does not support physical pagination.");

		// if have $SQL, replace by real sql
		String result = StringUtils.replace(pagintemplate, "$SQL", sql);
		// if have $BODY, replace by real body
		result = StringUtils.replace(result, "$BODY", body);
		result = StringUtils.replace(result, "$OFFSET", String.valueOf((pageNumber - 1) * pageSize));
		result = StringUtils.replace(result, "$MAX", String.valueOf(pageSize));
		result = StringUtils.replace(result, "$END", String.valueOf(pageNumber * pageSize));
		if (result.contains("$MSSQL_ORDERBY")) {

		}
		return result;
	}

	/**
	 * Guess Dialect by give databaseName, MajorVersion, majorVersion
	 * 
	 * @param databaseName
	 *            database name
	 * @param majorVersion
	 *            major version, Optional
	 * @param minorVersion
	 *            minor version, Optional
	 * @return dialect or null if not found
	 */
	public static Dialect guessDialect(Object... databaseName_majorVersion_minorVersion) {// NOSONAR
		String databaseName = "";
		int majorVersion = 0;
		int minorVersion = 0;
		for (int i = 0; i < databaseName_majorVersion_minorVersion.length; i++) {
			if (i == 0)
				databaseName = (String) databaseName_majorVersion_minorVersion[i];
			if (i == 1)
				majorVersion = (Integer) databaseName_majorVersion_minorVersion[i];
			if (i == 2)
				minorVersion = (Integer) databaseName_majorVersion_minorVersion[i];
		}
		if ("CUBRID".equalsIgnoreCase(databaseName))
			return CUBRID;
		if ("HSQL Database Engine".equals(databaseName))
			return HSQL;
		if ("H2".equals(databaseName))
			return H2;
		if ("MySQL".equals(databaseName))
			if (majorVersion >= 5)
				return MySQL5;
			else
				return MySQL;
		if ("PostgreSQL".equals(databaseName)) {
			if (majorVersion == 9) {
				if (minorVersion >= 4) {
					return PostgreSQL94;
				} else if (minorVersion >= 2) {
					return PostgreSQL92;
				}
				return PostgreSQL9;
			}
			if (majorVersion == 8 && minorVersion >= 2) {
				return PostgreSQL82;
			}
			return PostgreSQL81;
		}
		if ("EnterpriseDB".equals(databaseName))
			return PostgresPlus;
		if ("Apache Derby".equals(databaseName)) {
			if (majorVersion > 10 || (majorVersion == 10 && minorVersion >= 7))
				return DerbyTenSeven;
			else if (majorVersion == 10 && minorVersion == 6)
				return DerbyTenSix;
			else if (majorVersion == 10 && minorVersion == 5)
				return DerbyTenFive;
			else
				return Derby;
		}
		if ("ingres".equalsIgnoreCase(databaseName)) {
			switch (majorVersion) {
			case 9:
				if (minorVersion > 2)
					return Ingres9;
				else
					return Ingres;
			case 10:
				return Ingres10;
			default:
			}
			return Ingres;
		}
		if (databaseName.startsWith("Microsoft SQL Server")) {
			switch (majorVersion) {
			case 8:
				return SQLServer;
			case 9:
				return SQLServer2005;
			case 10:
				return SQLServer2008;
			case 11:
			case 12:
			case 13:
				return SQLServer2012;
			default:
				if (majorVersion < 8)
					return SQLServer;
				else
					return SQLServer2012;
			}
		}
		if ("Sybase SQL Server".equals(databaseName) || "Adaptive Server Enterprise".equals(databaseName))
			return SybaseASE15;
		if (databaseName.startsWith("Adaptive Server Anywhere"))
			return SybaseAnywhere;
		if ("Informix Dynamic Server".equals(databaseName))
			return Informix;
		if ("DB2 UDB for AS/400".equals(databaseName))
			return DB2400;
		if (databaseName.startsWith("DB2/"))
			return DB2;
		if ("Oracle".equals(databaseName)) {
			switch (majorVersion) {
			case 12:
				return Oracle12c;
			case 11:
			case 10:
				return Oracle10g;
			case 9:
				return Oracle9i;
			case 8:
				return Oracle8i;
			default:
			}
			return Oracle8i;
		}
		if ("HDB".equals(databaseName))
			return HANAColumnStore;
		if (databaseName.startsWith("Firebird"))
			return Firebird;
		if (databaseName.toLowerCase().indexOf("sqlite") >= 0)
			return SQLite;
		return null;
	}

	/**
	 * Guess dialect based on given jdbc Connection
	 * 
	 * @param jdbcConnection
	 * @return dialect or null if not found
	 */
	public static Dialect guessDialect(Connection jdbcConnection) {
		String databaseName;
		int majorVersion;
		int minorVersion;
		try {
			DatabaseMetaData meta = jdbcConnection.getMetaData();
			databaseName = meta.getDatabaseProductName();
			majorVersion = meta.getDatabaseMajorVersion();
			minorVersion = meta.getDatabaseMinorVersion();
		} catch (SQLException e) {
			return (Dialect) DialectException.throwEX(e, e.getMessage());
		}
		return Dialect.guessDialect(databaseName, majorVersion, minorVersion);
	}

	/**
	 * Create a pagination SQL by given dialect, pageNumber, pageSize and SQL
	 * 
	 * @param dialect
	 *            Dialect
	 * @param pageNumber
	 *            pageNumber started from 0
	 * @param pageSize
	 *            page size
	 * @param sql
	 *            the original sql
	 * @return the pagination SQL String
	 */
	public static String pagin(Dialect dialect, int pageNumber, int pageSize, String sql) {
		if (dialect == null)
			return (String) DialectException.throwEX("dialect can not be null, please set a dialect first.");
		return dialect.pagin(pageNumber, pageSize, sql);
	}

}
