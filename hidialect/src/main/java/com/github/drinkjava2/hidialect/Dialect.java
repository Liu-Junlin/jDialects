/*
 * HiDialect, a tiny SQL dialect tool 
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
 * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
 */
package com.github.drinkjava2.hidialect;

import org.apache.commons.lang.StringUtils;

/**
 * <pre>
 * This is a Dialects for all kind of Databases, extracted from Hibernate
 * 
 * Note: Do not modify this file manually, it's generated by source code generator
 * 
 * </pre>
 *
 * @author Yong Zhu
 * @version 1.0.0
 * @since 1.0.0
 */
public enum Dialect {
	Cache71, CUBRID, DataDirectOracle9, DB2, DB2390, DB2400, Derby, DerbyTenFive, DerbyTenSeven, DerbyTenSix, Firebird, FrontBase, H2, HANAColumnStore, HANARowStore, HSQL, Informix, Informix10, Ingres, Ingres10, Ingres9, Interbase, JDataStore, MariaDB, MariaDB53, Mckoi, MimerSQL, MySQL, MySQL5, MySQL55, MySQL57, MySQL57InnoDB, MySQL5InnoDB, MySQLInnoDB, MySQLMyISAM, Oracle, Oracle10g, Oracle12c, Oracle8i, Oracle9, Oracle9i, Pointbase, PostgresPlus, PostgreSQL, PostgreSQL81, PostgreSQL82, PostgreSQL9, PostgreSQL91, PostgreSQL92, PostgreSQL93, PostgreSQL94, PostgreSQL95, Progress, RDMSOS2200, SAPDB, SQLServer, SQLServer2005, SQLServer2008, SQLServer2012, Sybase, Sybase11, SybaseAnywhere, SybaseASE15, SybaseASE157, Teradata, Teradata14, TimesTen;

	public static final String NOT_SUPPORTED = "NOT SUPPORT";

	public String getPaginSqlTemplate() {
		switch (this) {// NOSONAR
		case H2:
		case HANAColumnStore:
		case HANARowStore:
		case PostgresPlus:
		case PostgreSQL:
		case PostgreSQL81:
		case PostgreSQL82:
		case PostgreSQL9:
		case PostgreSQL91:
		case PostgreSQL92:
		case PostgreSQL93:
		case PostgreSQL94:
		case PostgreSQL95:
			return "$SQL limit $MAX offset $OFFSET";
		case CUBRID:
		case MariaDB:
		case MariaDB53:
		case MySQL:
		case MySQL5:
		case MySQL55:
		case MySQL57:
		case MySQL57InnoDB:
		case MySQL5InnoDB:
		case MySQLInnoDB:
		case MySQLMyISAM:
			return "$SQL limit $OFFSET, $MAX";
		case Ingres10:
		case Ingres9:
			return "$SQL offset $OFFSET fetch first $MAX rows only";
		case Derby:
		case DerbyTenFive:
		case DerbyTenSeven:
		case DerbyTenSix:
		case Oracle12c:
		case SQLServer2012:
			return "$SQL offset $OFFSET rows fetch next $MAX rows only";
		case Interbase:
			return "$SQL rows $OFFSET to $END";
		case Cache71:
		case DB2390:
		case FrontBase:
		case Informix:
		case Ingres:
		case JDataStore:
		case Mckoi:
		case MimerSQL:
		case Pointbase:
		case Progress:
		case RDMSOS2200:
		case SAPDB:
		case SQLServer:
		case Sybase:
		case Sybase11:
		case SybaseAnywhere:
		case SybaseASE15:
		case SybaseASE157:
		case Teradata:
		case Teradata14:
		case TimesTen:
			return NOT_SUPPORTED;
		case DB2:
		case DB2400:
			return "select * from ( select inner2_.*, rownumber() over(order by order of inner2_) as rownumber_ from ( $SQL fetch first $END rows only ) as inner2_ ) as inner1_ where rownumber_ > $OFFSET order by rownumber_";
		case Oracle:
		case Oracle8i:
			return "select * from ( select row_.*, rownum rownum_ from ( $SQL ) row_ ) where rownum_ <= $END and rownum_ > $OFFSET";
		case DataDirectOracle9:
		case Oracle10g:
		case Oracle9:
		case Oracle9i:
			return "select * from ( select row_.*, rownum rownum_ from ( $SQL ) row_ where rownum <= $END) where rownum_ > $OFFSET";
		case Firebird:
			return "select first $OFFSET skip $MAX $BODY";
		case HSQL:
			return "select limit $OFFSET $MAX $BODY";
		case Informix10:
			return "select SKIP $OFFSET FIRST $MAX $BODY";
		case SQLServer2005:
		case SQLServer2008:
			return "WITH query AS (SELECT inner_query.*, ROW_NUMBER() OVER (ORDER BY CURRENT_TIMESTAMP) as _rownum_ FROM ( select TOP($MAX) $BODY ) inner_query ) SELECT $MSSQL_ORDERBY FROM query WHERE _rownum_ >= $OFFSET AND _rownum_ < $END";
		default:
			return "";
		}
	}

	/**
	 * Create a pagination SQL by given pageNumber, pageSize and SQL
	 * 
	 * @param pageNumber
	 *            pageNumber started from 0
	 * @param pageSize
	 *            page size
	 * @param sql
	 *            the original sql
	 * @return the pagination SQL String
	 */
	public String pagin(int pageNumber, int pageSize, String sql) {
		if (!StringUtils.startsWithIgnoreCase(sql, "select "))
			return (String) DialectException.throwEX("SQL should be started with \"select \".");
		String body = StringUtils.substringAfter(sql, " ");
		String pagintemplate = this.getPaginSqlTemplate();
		if (Dialect.NOT_SUPPORTED.equals(pagintemplate))
			return (String) DialectException
					.throwEX("This dialect \"" + this + "\" does not support physical pagination.");

		// if have $SQL, replace by real sql
		String result = StringUtils.replaceOnce(pagintemplate, "$SQL", sql);
		// if have $BODY, replace by real body
		result = StringUtils.replaceOnce(result, "$BODY", body);
		result = StringUtils.replaceOnce(result, "$OFFSET", String.valueOf((pageNumber - 1) * pageSize));
		result = StringUtils.replaceOnce(result, "$MAX", String.valueOf(pageSize));
		result = StringUtils.replaceOnce(result, "$END", String.valueOf(pageNumber * pageSize));
		if (StringUtils.contains(result, "$MSSQL_ORDERBY")) {

		}
		return result;
	}

	/**
	 * Create a pagination SQL by given dialect, pageNumber, pageSize and SQL
	 * 
	 * @param dialect
	 *            Dialect
	 * @param pageNumber
	 *            pageNumber started from 0
	 * @param pageSize
	 *            page size
	 * @param sql
	 *            the original sql
	 * @return the pagination SQL String
	 */
	public static String pagin(Dialect dialect, int pageNumber, int pageSize, String sql) {
		if (dialect == null)
			return (String) DialectException.throwEX("dialect can not be null, please set a dialect first.");
		return dialect.pagin(pageNumber, pageSize, sql);
	}

}
